
# what is free() & malloc()
-  `malloc()` is a `dynamic memory allocator`, these are used when the program doesn't know the size or number of objects it'll need prior to runtime.
	-   malloc()'s job is to dish out "`chunks`" of dynamic memory to processes at runtime.
	-   these "chunks" come from large regions of memory known as heaps
![](https://i.imgur.com/FaQ02ns.png)

 - `free(void* p) Releases the chunk of memory pointed to by p`, that had been previously allocated using malloc or a related routine such as
 ![](https://i.imgur.com/2yRV2rx.png)
 
 - Internally, these functions use two system calls [sbrk](http://man7.org/linux/man-pages/man2/sbrk.2.html) and [mmap](http://man7.org/linux/man-pages/man2/mmap.2.html) to request and release heap memory from the operating system.
	- [This](https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/) post discusses these system calls in detail.

---

#### Chunk metadata
![](https://i.imgur.com/j4w3Emg.png)
- important notes: 
	- the chunk starts before your pointer
	- the pointers to the next/prev chunks overlap with data
		- they're only used if the chunk is free, so, no data
	 - chunks are 8 byte aligned
		 - so, lower 3 bits are used as flags for metadata

---

## Refresher:
- the heap grows down from low memory
- the stack grows up from high memory

---

## Bins
- chunks are organized in `Bins`
- each bin is a linked list of chunks
	- a linked list consists of nodes where each node contains a `data field` and a `pointer` to the next node in the list.
	- Visual Example:![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist.png)
	- `fastbins`, for very small chunks. Act like a stack.
	- `Unsorted bin`, for freed small/large chunks.
	- `small bins`, for... small chunks. Acts like a queue. FIFO structure (first in first out)
	- `Large bins`, for... large chunks
	- `tcache` stands for *Thread Local Cache* 
	![](https://i.imgur.com/Hjmg7Ii.png)

- when we ask for a chunk, glibc checks the bins
	- if we find one in the appropriate bin, we use it
	- if not, split the special topchunk and use that
	- if the top chunk is too small, ask for more memory
- so, at first it just carves up the top chunk
- once we free some chunks they get reused

---

### Recap:
- each chunk of memory has metadata on it
- chunks are kept in bins: linked lists
- allocations are served from those bins, if possible
- there's a lot of state being tracked
- lots of room for corruption...

---
## Arenas

![](https://0x434b.dev/content/images/2022/02/image-8.png)
- An arena is not more than a state struct for malloc to use. An arena primarily consists of the bins, among a few other noteworthy fields. 
- The `mutex` field serializes access to an arena. The flag field holds information about whether an arena's heap memory is contiguous. 
- The `have_fastchunks` boolean field indicates the fastbins may not be empty. 
- The `binmap` is a bitvector that loosely represents which of an arena's smallbins &amp; largebins are occupied. 
- It's used by malloc to quickly find the next largest, occupied bin when a request could not be serviced. 
- `Binmap` searches occur after an unsuccessful unsortedbin or largebin search. 
- The next field is a pointer to a singly linked, circular lost of all arenas belonging to this arena. 
- `Next_free` is also a singly linked but non-circular list of free arenas (arenas with no threads attached). 
- `Attached_threads` is just the number of threads concurrently using this arena. 
- `System_mem` holds the value of the total writable memory currently mapped by this arena. 
- `Max_system_mem` is the largest amount of writable memory this arena had mapped at any point.

---
## Unlinking
- During allocation/free operations, chunks may be unlinked from any of the free lists (bins) they were stored in. The unlinked chunk is often referred to as "victim" in the malloc source. Unlinking in fastbins/tcache is straightforward, as they're singly linked LIFO lists. The process only involves copying the victim's fd into the head of the list, which then points to the next free chunk following our victim, effectively removing the victim from the list. There's a partial unlinking process for bins allocated from the small-/unsortedbin. The victim's chunk bk is followed to the previous chunk. There, the address of the head of the bin is copied into the chunk's fd. Finally, the victim chunk's bk is copied over the bk of the head of the bin. Lastly, there's also the notion of a full unlink that occurs when a chunk is consolidated into another free chunk or is allocated from the largebin. In the process, the victim chunk's fd is followed and the victim bk is copied over to the destination bk. Next, the victim chunk's bk is followed and the victim fd is copied over the destination fd.

---
## Remaindering
- Remaindering is simply the term referrRemaindering is simply the term referring to splitting a chunk into two parts, the requested size one and the remainder. The remainder is linked into the unsortedbin. Remaindering can occur at three phases: During allocation from the largebins, during binmap search, and from a last remainder during unsortedbin scanninging to splitting a chunk into two parts, the requested size one and the remainder. The remainder is linked into the unsortedbin. Remaindering can occur at three phases: During allocation from the largebins, during binmap search, and from a last remainder during unsortedbin scanning.

---
## Exhausting

- Simply the term for when an N sized chunk is requested and only an N+0x10 sized chunk is found, e.g. in the unsortedbin. A remainder of 0x10 is an invalid chunk size, so malloc will just "exhaust" the whole N+0x10 chunk and allocate that one as is.

---
## Consolidation
- Consolidation is the process of merging at least two free chunks on the heap into a larger free chunk to avoid fragmentation. Consolidation with the top chunk is also worth noting.

---
## **Hooks**

These hooks have been a hell of helpful in past exploitation techniques, but due to them enabling numerous techniques showcased below, they have been removed in [**GL**IBC 2 .**3**4](https://patchwork.sourceware.org/project/glibc/patch/20210713073845.504356-10-siddhesh@sourceware.org/)

-   `__malloc_hook`/ `__free_hook` / `__realloc_hook`: Located in a writable segment within the GLIBC. These pointers, defaulting to 0 but when set, result in instead of the default GLIBC malloc/realloc/free functionality being called the function pointed to the value being set within these hooks being called on an allocation/free.

-   `__after_morecore_hook`: The variable `__after_morecore_hook` points at a function that is called each time after `sbrk()` was asked for more memory.

-   `__malloc_initialize_hook`: The variable `__malloc_initialize_hook` points to a function that is called once when the malloc implementation is initialized. So overwriting it with an attacker controlled value would just be useful when malloc has never been called before.

-   `__memalign_hook`: When set and `aligned_alloc()`, `memalign()`, `posix_memalign()`, or `valloc()` are being invoked, these function pointed to by the address stored in this hook is being called instead

-   `_dl_open_hook`: When triggering an abort message in GLIBC, typically `backtrace_and_maps()` to print the stderr trace is called. When this happens, `__backtrace()` and within that code `init()` is called, where `__libc_dlopen()` and `__libc_dlsym()` are invoked. The gist is that IF `_dl_open_hook` is not NULL, `_dl_open_hook`⇾`dlopen_mode` and `_dl_open_hook`⇾`dlsym` will be called. So, the idea is to just overwrite _dl_open_hook with an address an attacker controls where a fake vtable function table can be crafted

